/*
 *  Copyright 2017 Nicholas Moehle
 *  
 *  This file is part of CVXPY-CODEGEN.
 *  
 *  CVXPY-CODEGEN is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  CVXPY-CODEGEN is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with CVXPY-CODEGEN.  If not, see <http://www.gnu.org/licenses/>.
 */

{% import "utils/utils.c.jinja" as u with context %}
#include "codegen.h"
{% if include_solver %}
#include "ecos.h"
{% endif %}
#include <math.h>
#include <stdio.h> // TODO


{{ u.print_cscmat_declare() }}
{{ u.print_vec_declare() }}


{% macro solver_workspace(include_solver=True) -%}
    
    {% if include_solver %}
    pwork *solver_work;
    {% endif %}

    /* Problem coefficients. */

    /* Storage for the equality constraints. */
    CscMatrix eq_coeff;
    double eq_nzval[{{ eq_coeff.nnz }}];
    double eq_offset[{{ eq_dim }}];

    /* Storage for the inequality constraints. */
    CscMatrix leq_coeff;
    double leq_nzval[{{ leq_coeff.nnz }}];
    double leq_offset[{{ cone_dim }}];

    /* Storage for the objective vector. */
    CscMatrix obj_coeff;
    double obj_nzval[{{ obj_coeff.nnz }}];
    double obj_vec[{{ x_length }}];
    double obj_offset;
{%- endmacro %}


/* Sparsity pattern for the objective and constraint matrices. */
long obj_colptr{{ u.print_vec(obj_coeff.indptr) }};
long obj_rowidx{{ u.print_vec(obj_coeff.indices) }};
long eq_colptr{{ u.print_vec(eq_coeff.indptr) }};
long eq_rowidx{{ u.print_vec(eq_coeff.indices) }};
long leq_colptr{{ u.print_vec(leq_coeff.indptr) }};
long leq_rowidx{{ u.print_vec(leq_coeff.indices) }};


void add_matrix(long hshift, long vshift,
                CscMatrix *A, LinopCoeff *B);
void reset_colptr(long n, long *Ap);
void cscrow2vec(CscMatrix A, double *vec);
void csr_vectorize(CsrMatrix *A, double *x, long offset);





static long soc_sizes{{ u.print_vec(soc_dims) }};


/* Initialize ECOS. */
void solver_init(Work *work){

    work->eq_coeff.p = eq_colptr;
    work->eq_coeff.i = eq_rowidx;
    work->eq_coeff.x = work->eq_nzval;
    work->eq_coeff.m = {{ eq_coeff.shape[0] }};
    work->eq_coeff.n = {{ eq_coeff.shape[1] }};
    work->eq_coeff.nnz = {{ eq_coeff.nnz }};

    work->leq_coeff.p = leq_colptr;
    work->leq_coeff.i = leq_rowidx;
    work->leq_coeff.x = work->leq_nzval;
    work->leq_coeff.m = {{ leq_coeff.shape[0] }};
    work->leq_coeff.n = {{ leq_coeff.shape[1] }};
    work->leq_coeff.nnz = {{ leq_coeff.nnz }};

    work->obj_coeff.p = obj_colptr;
    work->obj_coeff.i = obj_rowidx;
    work->obj_coeff.x = work->obj_nzval;
    work->obj_coeff.m = {{ obj_coeff.shape[0] }};
    work->obj_coeff.n = {{ obj_coeff.shape[1] }};
    work->obj_coeff.nnz = {{ obj_coeff.nnz }};
    work->obj_offset = 0;


    /* Zero out the floating point values to avoid numerical difficulties. */
    long i;
    for (i=0; i<{{ eq_coeff.nnz }}; i++)  work->eq_nzval[i]   = 0;
    for (i=0; i<{{ leq_coeff.nnz }}; i++)  work->leq_nzval[i]  = 0;
    for (i=0; i<{{ eq_coeff.shape[0] }}; i++)  work->eq_offset[i]  = 0;
    for (i=0; i<{{ leq_coeff.shape[0] }}; i++)  work->leq_offset[i] = 0;
    for (i=0; i<{{ x_length }}; i++)  work->obj_vec[i]  = 0;


    {% if include_solver %}
    work->solver_work = ECOS_setup({{ x_length }}, {{ cone_dim }}, {{ eq_dim }},
             {{ leq_dim }}, {{ len(soc_dims) }}, soc_sizes, {{ exp_cones }}, 
             work->leq_coeff.x, work->leq_coeff.p, work->leq_coeff.i,
             work->eq_coeff.x, work->eq_coeff.p, work->eq_coeff.i,
             work->obj_vec, work->leq_offset, work->eq_offset);
    {% endif %}

}



/* Stuff matrices. */
void fill_matrices(Work *work){
    long i;

    /* Construct equality constraint. */
    {% for c in eq_constr %}
    {% for coeff in c.exprs[0].coeffs.values() %}
    add_matrix({{ var_offsets[coeff.vid] }}, {{ c.vert_offset }},
                  &work->eq_coeff, &work->{{ coeff.storage.name }});
  
    {% endfor %}
    {% if c.exprs[0].has_offset %} {# TODO wrong #}
    csr_vectorize(&work->{{ c.exprs[0].offset_expr.storage.name }}, {# TODO wrong #}
                  work->eq_offset, {{ c.vert_offset}});
    {% endif %}
    {% endfor %}
    reset_colptr({{  eq_coeff.shape[1] }},  eq_colptr);
  
    /* Construct iequality constraint. */
    {% for c in leq_constr %}
    {% for coeff in c.exprs[0].coeffs.values() %} {# TODO wrong #}
    add_matrix({{ var_offsets[coeff.vid] }}, {{ c.vert_offset }},
               &work->leq_coeff, &work->{{ coeff.storage.name }});
  
    {% endfor %}
    {% if c.exprs[0].has_offset %} {# TODO wrong #}
    csr_vectorize(&work->{{ c.exprs[0].offset_expr.storage.name }}, {# TODO wrong #}
                  work->leq_offset, {{ c.vert_offset}});
    {% endif %}
    {% endfor %}
    reset_colptr({{ leq_coeff.shape[1] }}, leq_colptr);
  
    /* Construct objective. */
    {% for coeff in objective.coeffs.values() %}
    add_matrix({{ var_offsets[coeff.vid] }}, 0,
               &work->obj_coeff, &work->{{ coeff.storage.name }});
    {% if objective.has_offset %}
    work->obj_offset = work->{{ objective.offset_expr.storage.name }}.x[0];
    {% endif %}
    {% endfor %}
    reset_colptr({{ obj_coeff.shape[1] }}, obj_colptr);
    cscrow2vec(work->obj_coeff, work->obj_vec);

    /* Convert from our format (Ax+b=0) to ECOS format (Ax=b). */
    for (i=0; i<{{  eq_coeff.shape[0] }}; i++)  work->eq_offset[i]  = -work->eq_offset[i];
    for (i=0; i<{{ leq_coeff.shape[0] }}; i++)  work->leq_offset[i] = -work->leq_offset[i];

}



/* Solve the problem using ECOS. */
void solver_solve(Work *work){


    {% if include_solver %}
    idxint solver_flag;
    
    {#
    {{ u.print_cscmat_eval('eq_coeff') }}
    {{ u.print_vec_eval('eq_offset', eq_coeff.shape[0]) }}
    {{ u.print_cscmat_eval('leq_coeff') }}
    {{ u.print_vec_eval('leq_offset', leq_coeff.shape[0]) }}
    {{ u.print_cscmat_eval('obj_coeff') }}
    {{ u.print_vec_eval('obj_vec', leq_coeff.shape[1]) }}
    #}

    ECOS_updateData(work->solver_work, work->leq_nzval, work->eq_nzval,
                     work->obj_vec, work->leq_offset, work->eq_offset);

    solver_flag = ECOS_solve(work->solver_work);

    work->primal_var = work->solver_work->x;
    work->dual_eq_var = work->solver_work->y;
    work->dual_ineq_var = work->solver_work->z;

    switch(solver_flag){

        case ECOS_OPTIMAL:
        case ECOS_OPTIMAL + ECOS_INACC_OFFSET:
            work->status = CG_OPTIMAL;
            work->optval = work->solver_work->info->pcost;
            break;

        case ECOS_PINF:
        case ECOS_PINF + ECOS_INACC_OFFSET:
            work->status = CG_INFEASIBLE;
            work->optval = INFINITY;
            break;
            
        case ECOS_DINF:
        case ECOS_DINF + ECOS_INACC_OFFSET:
            work->status = CG_UNBOUNDED;
            work->optval = -INFINITY;
            break;

        case ECOS_MAXIT:
        case ECOS_NUMERICS:
        case ECOS_OUTCONE:
        case ECOS_SIGINT:
        case ECOS_FATAL:
            work->status = CG_SOLVER_ERR;
            work->optval = NAN;
            break;

    }

    {% endif %}
} 


/* Clean up ECOS memory. */
void cg_cleanup(Work *work){
    {% if include_solver %}
    ECOS_cleanup(work->solver_work, 0);
    {% endif %}
}




void csr_vectorize(CsrMatrix *A, double *x, long offset){
    long i, j, p, p2, n_vec=A->m*A->n, m=A->m;
    for(i=offset; i<n_vec+offset; i++) x[i] = 0;
    for(i=0; i<m; i++){
        p2 = A->p[i+1];
        for(p=A->p[i]; p<p2; p++){
            j = A->j[p];
            x[offset + i + j*m] = A->x[p];
        }
    }
}




/* Converts a row vector, in CSC sparse matrix
 * format, into a dense vector.
 */
void cscrow2vec(CscMatrix A, double *vec){
  long i, count=0, n=A.n;
  for (i=0; i<n; i++){
    vec[i] = A.p[i] < A.p[i+1] ? A.x[count++] : 0;
  }
}






void add_matrix(long hshift, long vshift,
                CscMatrix *A, LinopCoeff *B){
  long i, j, p, p2, pA, m=B->m;
  for (i=0; i<m; i++){
    p2 = B->p[i+1];
    for (p=B->p[i]; p<p2; p++){
      j = B->j[p];
      pA = A->p[j+hshift]++; // TODO clean up
      // A->i[pA] = i+vshift; // TODO remove?
      A->x[pA] = B->x[p];
    }
  }
}



void reset_colptr(long n, long *Ap){
  int i;
  for (i=n; i>0; i--){
    Ap[i] = Ap[i-1];
  }
  Ap[0] = 0; 
}




{% macro makefile_target() -%}
     libecos.a
{%- endmacro %} 


{{ u.print_cscmat_define() }}

{{ u.print_vec_define() }}
