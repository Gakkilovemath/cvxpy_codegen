/*
 *  Copyright 2017 Nicholas Moehle
 *  
 *  This file is part of CVXPY-CODEGEN.
 *  
 *  CVXPY-CODEGEN is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  CVXPY-CODEGEN is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with CVXPY-CODEGEN.  If not, see <http://www.gnu.org/licenses/>.
 */

{% import "utils/utils.c.jinja" as u with context %}
{% import "atoms/linops.c.jinja" as lo with context %}
{% import "atoms/atoms.c.jinja" as atoms with context %}
#include "codegen.h"
#include <stdio.h>

{# TODO debug #}


{{ u.print_linopcoeff_declare() }}

{{ u.print_csrmat_declare() }}


{# This is the storage needed to process the expression trees
 # into matrices.
 #}

{% macro expr_handler_workspace() %}

    /* Storage for the parameters. */
    {% for p in named_params %}
    CsrMatrix {{ p.name }};
    long    {{ p.name }}_rowptr[{{ p.shape[0]+1 }}];
    long    {{ p.name }}_colidx[{{ p.sparsity.nnz }}];
    double *{{ p.name }}_nzval;

    {% endfor %}
    {% if expressions %}
    /* Storage for intermediate results from expression evaluation (if any): */
    {% for expr in expressions %}
    {% if not expr.inplace or expr.make_copy %}
    CsrMatrix {{ expr.name }};
    long   {{ expr.name }}_rowptr[{{ expr.shape[0]+1 }}];
    long   {{ expr.name }}_colidx[{{ expr.sparsity.nnz }}];
    double {{ expr.name }}_nzval[{{ expr.sparsity.nnz }}];

    {% endif %}
    {% endfor %}

    /* Storage for the callback parameters (if any): */
    {% for cbp in callback_params %}
    CscMatrix {{ cbp.cbp_name }};
    long   {{cbp.cbp_name}}_colptr[{{ cbp.shape[1]+1 }}];
    long   {{cbp.cbp_name}}_rowidx[{{ cbp.sparsity.nnz }}];
    double {{cbp.cbp_name}}_nzval[{{ cbp.sparsity.nnz }}];

    {% endfor %}
    {% endif %}
    /* Storage for the linear operator coefficients: */
    {% for c in linop_coeffs %}
    {% if not c.inplace or c.make_copy %}
    LinopCoeff {{ c.name }};
    long {{ c.name }}_rowptr[{{ c.sparsity.shape[0]+1 }}];
    long {{ c.name }}_colidx[{{ c.sparsity.nnz }}];
    double {{ c.name }}_nzval[{{ c.sparsity.nnz }}];
    {% endif %}

    {% endfor %}
    /* Storage for coefficients corresponding to variables: */
    {% for v in vars %}
    LinopCoeff {{ v.name }};
    long   {{ v.name }}_rowptr[{{ v.sparsity.nnz+1 }}];
    long   {{ v.name }}_colidx[{{ v.sparsity.nnz }}];
    double {{ v.name }}_nzval[{{ v.sparsity.nnz }}];

    {% endfor %}
    /* Matrices for referencing constants. (Data stored elsewhere.) */
    {% for c in constants %}
    CsrMatrix {{ c.name }};

    {% endfor %}

    // TODO more storage, for linop data
{% endmacro %}



/*
 * CONSTANTS!
 */

{% if constants %}
/* Stored constant values. */
{% for c in constants %}
long   {{ c.name }}_rowptr{{ u.print_vec(c.rowptr) }};
long   {{ c.name }}_colidx{{ u.print_vec(c.colidx) }};
double {{ c.name }}_nzval{{ u.print_vec(c.nzval) }};

{% endfor %}
{% endif %}




/*
 * FUNCTION DECLARATIONS!
 */

void init_var_coeff(long m_var, long n_var, LinopCoeff *A);
void init_dense_sparsity(CsrMatrix A);
{{ u.copy_declare() }} {# TODO add logic to python for including this or not #}
{{ u.copy_linop_declare() }} {# TODO add logic to python for including this or not #}
{% for linop_name in unique_linops %}
  {{- lo.declare(linop_name) }}
{% endfor %}
{% for expr_name in unique_atoms %}
  {{- atoms.declare(expr_name) }}
{% endfor %}




/* 
 * FUNCTION DEFINITIONS!
 */

void expr_handler_init(Work *work){
 
    {% for e in expressions %}
    {% if not e.inplace or e.make_copy %}
    work->{{ e.name }}.p = work->{{ e.name }}_rowptr;
    work->{{ e.name }}.j = work->{{ e.name }}_colidx;
    work->{{ e.name }}.x = work->{{ e.name }}_nzval;
    work->{{ e.name }}.m = {{ e.shape[0] }};
    work->{{ e.name }}.n = {{ e.shape[1] }};
    work->{{ e.name }}.nnz = {{ e.sparsity.nnz }};
    {% endif %}

    {% endfor %}
    {% for c in linop_coeffs  %}
    {% if not c.inplace or c.make_copy %}
    work->{{ c.name }}.p = work->{{ c.name }}_rowptr;
    work->{{ c.name }}.j = work->{{ c.name }}_colidx;
    work->{{ c.name }}.x = work->{{ c.name }}_nzval;
    work->{{ c.name }}.m = {{ c.sparsity.shape[0] }};
    work->{{ c.name }}.n = {{ c.sparsity.shape[1] }};
    work->{{ c.name }}.nnz = {{ c.sparsity.nnz }};
    work->{{ c.name }}.m_var = {{ c.shape[0] }};
    work->{{ c.name }}.n_var = {{ c.shape[1] }};
    {% endif %}

    {% endfor %}
    /* Storage for coefficients corresponding to variables. */
    {% for v in vars %}
    work->{{ v.name }}.p = work->{{ v.name }}_rowptr;
    work->{{ v.name }}.j = work->{{ v.name }}_colidx;
    work->{{ v.name }}.x = work->{{ v.name }}_nzval;
    init_var_coeff({{ v.shape[0]}}, {{v.shape[1]}}, &work->{{ v.name }});

    {% endfor %}
    /* Storage for linop coefficients representing constants. */
    {% for c in constants %}
    work->{{ c.name }}.p = {{ c.name }}_rowptr;
    work->{{ c.name }}.j = {{ c.name }}_colidx;
    work->{{ c.name }}.x = {{ c.name }}_nzval;
    work->{{ c.name }}.m = {{ c.shape[0] }};
    work->{{ c.name }}.n = {{ c.shape[1] }};
    work->{{ c.name }}.nnz = {{ c.sparsity.nnz }};

    {% endfor %}
    {% for p in named_params %}
    work->{{ p.name }}.p = work->{{ p.name }}_rowptr;
    work->{{ p.name }}.j = work->{{ p.name }}_colidx;
    work->{{ p.name }}.m = {{ p.shape[0] }};
    work->{{ p.name }}.n = {{ p.shape[1] }};
    work->{{ p.name }}.nnz = {{ p.sparsity.nnz }};

    init_dense_sparsity(work->{{ p.name }});
    {% endfor %}
    
    {#
    {% for cbp in callback_params %}
    work->{{ cbp.cbp_name }}.p = work->{{ cbp.cbp_name }}_colptr;
    work->{{ cbp.cbp_name }}.i = work->{{ cbp.cbp_name }}_rowidx;
    work->{{ cbp.cbp_name }}.x = work->{{ cbp.cbp_name }}_nzval;
    work->{{ cbp.cbp_name }}.m = {{ cbp.shape[0] }};
    work->{{ cbp.cbp_name }}.n = {{ cbp.shape[1] }};
    work->{{ cbp.cbp_name }}.nnz = {{ cbp.sparsity.nnz }};

    {% endfor %}
    #}

}




void eval_exprs(Params *params, Work *work){

  {# TODO Cut out the nzval pointer work struct, reduce this part: #}
  {% for p in named_params %}
  {{u.nzval(p)}} = &(params->{{ p.name -}}
      {%- if p.is_scalar() -%}
      {%- elif p.is_vector() -%}
          [0]
      {%- else -%}
          [0][0]
      {%- endif -%});
  work->{{ p.name }}.x = work->{{ p.name }}_nzval;

  {% endfor %}
  /* Evaluate expressions. */
  {% for expr in expressions %}
  {{ atoms.eval(expr) -}}
  {#{{ u.print_csrmat_eval(expr) }}#}

  {% endfor %}

  /* Evaluate linear operator coefficients. */
  {% for coeff in linop_coeffs %}
  {{ lo.eval(coeff) -}}
  {#{{ u.print_linopcoeff_eval(coeff) }}#}

  {% endfor %}
}



void init_var_coeff(long m_var, long n_var, LinopCoeff *A){
    long m = m_var*n_var;
    A->m_var = m_var;
    A->n_var = n_var;
    A->m = m;
    A->n = m;
    A->nnz = m;
    long i;
    A->p[0] = 0;
    for(i=0; i<m; i++){
        A->p[i+1] = A->p[i]+1;
        A->j[i] = i;
        A->x[i] = 1.0;
    }
}



void init_dense_sparsity(CsrMatrix A){
    long i, j, m=A.m, n=A.n;
    for(i=0; i<m; i++){
        A.p[i] = i*n;
        for(j=0; j<n; j++){
            A.j[i * n + j] = j;
        }
        A.p[m] = m*n;
    }
}






/* These are the linop definitions. */
{% for linop_name in unique_linops %}
  {{- lo.define(linop_name) }}
{% endfor %}

/* These are all the atom definitions. */
{% for expr_name in unique_atoms %}
  {{- atoms.define(expr_name) }}
{% endfor %}



{{ u.copy_linop_define() }}

{{ u.copy_define() }} // todo add logic to python for this

{{ u.print_linopcoeff_define() }}

{{ u.print_csrmat_define() }}
