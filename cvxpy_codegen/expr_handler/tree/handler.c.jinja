/*
 *  Copyright 2017 Nicholas Moehle
 *  
 *  This file is part of CVXPY-CODEGEN.
 *  
 *  CVXPY-CODEGEN is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  CVXPY-CODEGEN is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with CVXPY-CODEGEN.  If not, see <http://www.gnu.org/licenses/>.
 */

{% import "utils/utils.c.jinja" as u with context %}
{% import "atoms/linops.c.jinja" as lo with context %}
{% import "atoms/atoms.c.jinja" as atoms with context %}
#include "codegen.h"
#include "constants.h"


{% if debug %}
    #include <stdio.h>
    {{ u.print_linopcoeff_declare() }}
    {{ u.print_csrmat_declare() }}
    {{ u.print_linopcoeff_define() }}
    {{ u.print_csrmat_define() }}
{% endif %}


{# This is the storage needed to process the expression trees
 # into matrices.
 #}

{% macro expr_handler_workspace() %}

    /* Storage for the parameters. */
    {% for p in named_params %}
    CsrMatrix {{ p.name }};
    long    {{ p.name }}_rowptr[{{ p.shape[0]+1 }}];
    long    {{ p.name }}_colidx[{{ p.sparsity.nnz }}];
    double *{{ p.name }}_nzval;

    {% endfor %}
    {% if expressions %}
    /* Storage for intermediate results from expression evaluation (if any): */
    {% for expr in expressions %}
    {% if not expr.inplace or expr.make_copy %}
    CsrMatrix {{ expr.name }};
    long   {{ expr.name }}_rowptr[{{ expr.shape[0]+1 }}];
    long   {{ expr.name }}_colidx[{{ expr.sparsity.nnz }}];
    double {{ expr.name }}_nzval[{{ expr.sparsity.nnz }}];

    {% endif %}
    {% endfor %}

    /* Storage for the callback parameters (if any): */
    {% for cbp in callback_params %}
    CscMatrix {{ cbp.cbp_name }};
    long   {{cbp.cbp_name}}_colptr[{{ cbp.shape[1]+1 }}];
    long   {{cbp.cbp_name}}_rowidx[{{ cbp.sparsity.nnz }}];
    double {{cbp.cbp_name}}_nzval[{{ cbp.sparsity.nnz }}];

    {% endfor %}
    {% endif %}
    /* Storage for the linear operator coefficients: */
    {% for c in linop_coeffs %}
    {% if not c.inplace or c.make_copy %}
    LinopCoeff {{ c.name }};
    long {{ c.name }}_rowptr[{{ c.sparsity.shape[0]+1 }}];
    long {{ c.name }}_colidx[{{ c.sparsity.nnz }}];
    double {{ c.name }}_nzval[{{ c.sparsity.nnz }}];
    {% endif %}

    {% endfor %}
    /* Storage for coefficients corresponding to variables: */
    {% for v in vars.values() %}
    LinopCoeff {{ v.name }};
    long   {{ v.name }}_rowptr[{{ v.sparsity.nnz+1 }}];
    long   {{ v.name }}_colidx[{{ v.sparsity.nnz }}];
    double {{ v.name }}_nzval[{{ v.sparsity.nnz }}];

    {% endfor %}
    /* Matrices for referencing constants. (Data stored elsewhere.) */
    {% for c in constants %}
    CsrMatrix {{ c.name }};

    {% endfor %}
    {% for f in aff_operators %}
    CscMatrix {{ f.name }}_coeff;
    long *{{ f.name }}_colptr;
    long *{{ f.name }}_rowidx;
    double {{ f.name }}_nzval[{{ f.coeff.nnz }}];
    double {{ f.name }}_offset[{{ f.shape[0] }}];

    {% endfor %}
    {% for f in aff_functionals %}
    double {{ f.name }}_coeff[{{ f.shape[1] }}];
    double {{ f.name }}_offset;

    {% endfor %}
    {% for f in quad_forms %}
    /* Space for the quadratic coefficients. */
    CscMatrix {{ f.name }}_coeff;
    double {{ f.name }}_nzval[{{ f.sparsity.nnz }}];
    
    {% endfor %}
{% endmacro %}



{% macro constants_define() %}
{% if constants %}
/* Stored constant values. */
{% for c in constants %}
long   {{ c.name }}_rowptr{{ u.print_vec(c.rowptr) }};
long   {{ c.name }}_colidx{{ u.print_vec(c.colidx) }};
double {{ c.name }}_nzval{{ u.print_vec(c.nzval) }};

{% endfor %}
{% endif %}

/* Sparsity pattern for the objective and constraint matrices. */
{% for f in aff_operators %}
long {{ f.name }}_colptr{{ u.print_vec(f.coeff.indptr) }};
long {{ f.name }}_rowidx{{ u.print_vec(f.coeff.indices) }};

{% endfor %}
{% for f in quad_forms %}
long {{ f.name }}_colptr{{ u.print_vec(f.sparsity.indptr) }};
long {{ f.name }}_rowidx{{ u.print_vec(f.sparsity.indices) }};

{% endfor %}
{% endmacro %}



/*
 * FUNCTION DECLARATIONS
 */

void add_matrix(long hshift, long vshift, CscMatrix *A,
                LinopCoeff *B, double alpha, int triu);
void add_matrix_quad(long hshift, long repeats, CscMatrix *A,
                     CsrMatrix *B, LinopCoeff *C, double *work);
void add_matrix_quad_elemwise(long shift, CscMatrix *A, CsrMatrix *B,
                              LinopCoeff *C, double *work);
void add_matrix(long hshift, long vshift, CscMatrix *A, LinopCoeff *B, double alpha, int triu);
void add_matrix_quad(long hshift, long repeats,
                     CscMatrix *A, CsrMatrix *B, LinopCoeff *C, double *work);
void add_vector(long hshift, double *a, LinopCoeff *B);
void reset_colptr(long n, long *Ap);
void cscrow2vec(CscMatrix A, double *vec);
void csr_vectorize(CsrMatrix *A, double *x, long offset);
void init_var_coeff(long m_var, long n_var, LinopCoeff *A);
void init_dense_sparsity(CsrMatrix A);
{{ u.copy_declare() }} {# TODO add logic to python for including this or not #}
{{ u.copy_linop_declare() }} {# TODO add logic to python for including this or not #}
{% for linop_name in unique_linops %}
  {{- lo.declare(linop_name) }}
{% endfor %}
{% for expr_name in unique_atoms %}
  {{- atoms.declare(expr_name) }}
{% endfor %}




/* 
 * FUNCTION DEFINITIONS
 */

void expr_handler_init(Work *work){
    long i;

    {% for e in expressions %}
    {% if not e.inplace or e.make_copy %}
    work->{{ e.name }}.p = work->{{ e.name }}_rowptr;
    work->{{ e.name }}.j = work->{{ e.name }}_colidx;
    work->{{ e.name }}.x = work->{{ e.name }}_nzval;
    work->{{ e.name }}.m = {{ e.shape[0] }};
    work->{{ e.name }}.n = {{ e.shape[1] }};
    work->{{ e.name }}.nnz = {{ e.sparsity.nnz }};
    {% endif %}

    {% endfor %}
    {% for c in linop_coeffs  %}
    {% if not c.inplace or c.make_copy %}
    work->{{ c.name }}.p = work->{{ c.name }}_rowptr;
    work->{{ c.name }}.j = work->{{ c.name }}_colidx;
    work->{{ c.name }}.x = work->{{ c.name }}_nzval;
    work->{{ c.name }}.m = {{ c.sparsity.shape[0] }};
    work->{{ c.name }}.n = {{ c.sparsity.shape[1] }};
    work->{{ c.name }}.nnz = {{ c.sparsity.nnz }};
    work->{{ c.name }}.m_var = {{ c.shape[0] }};
    work->{{ c.name }}.n_var = {{ c.shape[1] }};
    {% endif %}

    {% endfor %}
    /* Storage for coefficients corresponding to variables. */
    {% for v in vars.values() %}
    work->{{ v.name }}.p = work->{{ v.name }}_rowptr;
    work->{{ v.name }}.j = work->{{ v.name }}_colidx;
    work->{{ v.name }}.x = work->{{ v.name }}_nzval;
    init_var_coeff({{ v.shape[0]}}, {{v.shape[1]}}, &work->{{ v.name }});

    {% endfor %}
    /* Storage for linop coefficients representing constants. */
    {% for c in constants %}
    work->{{ c.name }}.p = {{ c.name }}_rowptr;
    work->{{ c.name }}.j = {{ c.name }}_colidx;
    work->{{ c.name }}.x = {{ c.name }}_nzval;
    work->{{ c.name }}.m = {{ c.shape[0] }};
    work->{{ c.name }}.n = {{ c.shape[1] }};
    work->{{ c.name }}.nnz = {{ c.sparsity.nnz }};

    {% endfor %}
    {% for p in named_params %}
    work->{{ p.name }}.p = work->{{ p.name }}_rowptr;
    work->{{ p.name }}.j = work->{{ p.name }}_colidx;
    work->{{ p.name }}.m = {{ p.shape[0] }};
    work->{{ p.name }}.n = {{ p.shape[1] }};
    work->{{ p.name }}.nnz = {{ p.sparsity.nnz }};

    init_dense_sparsity(work->{{ p.name }});
    {% endfor %}
    
    {% for op in aff_operators %}
    work->{{ op.name }}_coeff.p = {{ op.name }}_colptr;
    work->{{ op.name }}_coeff.i = {{ op.name }}_rowidx;
    work->{{ op.name }}_coeff.x = work->{{ op.name }}_nzval;
    work->{{ op.name }}_coeff.m = {{ op.coeff.shape[0] }};
    work->{{ op.name }}_coeff.n = {{ op.coeff.shape[1] }};
    work->{{ op.name }}_coeff.nnz = {{ op.coeff.nnz }};
    for (i=0; i<{{ op.coeff.shape[0] }}; i++){
        work->{{ op.name }}_offset[i] = 0;
    }
    {% endfor %}
    {% for op in aff_functionals %}
    for (i=0; i<{{ op.coeff.shape[1] }}; i++){
        work->{{ op.name }}_coeff[i] = 0;
    }
    work->{{ op.name }}_offset = 0;
    {% endfor %}


    {% for op in quad_forms %}
    work->{{ op.name }}_coeff.p = {{ op.name }}_colptr;
    work->{{ op.name }}_coeff.i = {{ op.name }}_rowidx;
    work->{{ op.name }}_coeff.x = work->{{ op.name }}_nzval;
    work->{{ op.name }}_coeff.m = {{ op.sparsity.shape[0] }};
    work->{{ op.name }}_coeff.n = {{ op.sparsity.shape[1] }};
    work->{{ op.name }}_coeff.nnz = {{ op.sparsity.nnz }};

    {% endfor %}
}




void fill_matrices(Params *params, Work *work){

    {# TODO Cut out the nzval pointer work struct, reduce this part: #}
    {% for p in named_params %}
    {{u.nzval(p)}} = &(params->{{ p.name -}}
        {%- if p.is_scalar() -%}
        {%- elif p.is_vector() -%}
            [0]
        {%- else -%}
            [0][0]
        {%- endif -%});
    work->{{ p.name }}.x = work->{{ p.name }}_nzval;
        {% if debug %}
            {{ u.print_csrmat_eval(p) }}
        {% endif %}

    {% endfor %}

    /* Evaluate expressions. */
    {% for expr in expressions %}
    {# {{ atoms.eval(expr) -}} #}
    {{ expr.codegen() -}}
        {% if debug %}
            {{ u.print_csrmat_eval(expr) }}
        {% endif %}
    {% endfor %}

    /* Evaluate linear operator coefficients. */
    {% for coeff in linop_coeffs %}
    {# {{ lo.eval(coeff) -}} #}
    {{ coeff.codegen() -}}
        {% if debug %}
            {{ u.print_linopcoeff_eval(coeff) }}
        {% endif %}

    {% endfor %}

    /* Fill the coefficients for all affine operators and functionals.  */
    {% for op in aff_operators %}
    /* Fill in coeffs for the "{{ op.name }}" affine operator. */
    {% for vert_offset, e in zip(op.vert_offsets, op.exprs) %}
    {% for coeff in e.coeffs.values() %}
    add_matrix({{ var_offsets[coeff.vid] }}, {{ vert_offset }}, &work->{{ op.name }}_coeff, &work->{{ coeff.storage.name }}, 1.0, 0);
    {% endfor %}
    {% if e.has_offset %}
    csr_vectorize(&work->{{ e.offset_expr.storage.name }}, work->{{ op.name }}_offset, {{ vert_offset}});
    {% endif %}

    {% endfor %}
    reset_colptr({{ op.shape[1] }}, work->{{ op.name }}_coeff.p);

    {% endfor %}
    {% for op in aff_functionals %}
    /* Fill in coeffs for the "{{ op.name }}" affine functional. */
    {% for e in op.exprs %}
    {% for coeff in e.coeffs.values() %}
    add_vector({{ var_offsets[coeff.vid] }},
               work->{{ op.name }}_coeff, &work->{{ coeff.storage.name }});
    {% if e.has_offset %}
    work->{{ op.name }}_offset = work->{{ e.offset_expr.storage.name }}.x[0];
    {% endif %}
    {% endfor %}
    {% endfor %}

    {% endfor %}
    /* Fill the coefficients for quadratic forms.  */
    {% for op in quad_forms %}
    {% for qc in op.quad_coeffs %}
    {% if qc.is_elemwise %}
    add_matrix_quad_elemwise({{ qc.var_offset }}, &work->{{ op.name }}_coeff, &work->{{ qc.P_data.storage.name }}, &work->{{ qc.coeff.storage.name }}, work->work_double);
    {% else %}
    add_matrix_quad({{ qc.var_offset }}, {{ qc.shape[0] }}, &work->{{ op.name }}_coeff, &work->{{ qc.P_data.offset_expr.storage.name }}, &work->{{ qc.coeff.storage.name }}, work->work_double);
    {% endif %}
    {% endfor %}

    reset_colptr({{ x_length }}, work->{{ op.name }}_coeff.p);
    {% endfor %}

}



void csr_vectorize(CsrMatrix *A, double *x, long offset){
    long i, j, p, p2, n_vec=A->m*A->n, m=A->m;
    for(i=offset; i<n_vec+offset; i++) x[i] = 0;
    for(i=0; i<m; i++){
        p2 = A->p[i+1];
        for(p=A->p[i]; p<p2; p++){
            j = A->j[p];
            x[offset + i + j*m] = A->x[p];
        }
    }
}




/* Converts a row vector, in CSC sparse matrix
 * format, into a dense vector.
 */
void cscrow2vec(CscMatrix A, double *vec){
  long i, count=0, n=A.n;
  for (i=0; i<n; i++){
    vec[i] = A.p[i] < A.p[i+1] ? A.x[count++] : 0;
  }
}






void add_matrix(long hshift, long vshift,
                CscMatrix *A, LinopCoeff *B, double alpha, int triu){
  long i, j, p, p2, pA, m=B->m;
  for (i=0; i<m; i++){
    p2 = B->p[i+1];
    for (p=B->p[i]; p<p2; p++){
      j = B->j[p];
      if (!triu || i <= j){
        pA = A->p[j+hshift]++; // TODO clean up
        // A->i[pA] = i+vshift; // TODO remove?
        A->x[pA] = alpha * B->x[p];
      }
    }
  }
}




void add_matrix_quad(long shift, long repeats, CscMatrix *A,
                     CsrMatrix *B, LinopCoeff *C, double *work){
  long j, k, p, new_shift;

  for (j=0; j<C->m*C->n; j++)  work[j] = 0;
  for (p=0; p<C->nnz; p++){
      j = C->j[p];
      work[j] = 2*C->x[p]; /* The two accounts for the 1/2 in 1/2*x'*P*x. */
  }

  for (k=0; k<repeats; k++){
    new_shift = shift + k*B->n;
    add_matrix(new_shift, new_shift, A, B, work[k], 1);
  }
}



void add_matrix_quad_elemwise(long shift, CscMatrix *A, CsrMatrix *B, LinopCoeff *C,
                              double *work){
  long i, j, p, p2;

  for (j=0; j<C->m*C->n; j++)  work[j] = 0;
  for (p=0; p<C->nnz; p++){
      j = C->j[p];
      work[j] = 2*C->x[p]; /* The two accounts for the 1/2 in 1/2*x'*P*x. */
  }

  for (i=0; i<B->m; i++){
    p2 = B->p[i+1];
    for (p=B->p[i]; p<p2; p++){
      B->x[p] = B->x[p] * work[i];
    }
  }
  add_matrix(shift, shift, A, B, 1.0, 1);
}



void add_vector(long hshift, double *a, LinopCoeff *B){
  long i, j, p, p2, m=B->m;
  for (i=0; i<m; i++){
    p2 = B->p[i+1];
    for (p=B->p[i]; p<p2; p++){
      j = B->j[p];
      a[j+hshift] = B->x[p];
    }
  }
}



void reset_colptr(long n, long *Ap){
  int i;
  for (i=n; i>0; i--){
    Ap[i] = Ap[i-1];
  }
  Ap[0] = 0; 
}






/* These are the linop definitions. */
{% for linop_name in unique_linops %}
  {{- lo.define(linop_name) }}
{% endfor %}

/* These are all the atom definitions. */
{% for expr_name in unique_atoms %}
  {{- atoms.define(expr_name) }}
{% endfor %}


{{ u.copy_linop_define() }}

{{ u.copy_define() }} // TODO add logic to python for this
