{% import "utils/utils.c.jinja" as u with context %}
{% import "atoms/atoms.c.jinja" as atoms with context %}
#include "codegen.h"
#include <stdio.h> {# TODO #}


{% macro param_handler_workspace() %}
    /* Storage for the parameters. */
    {% for p in named_params %}
    CsrMatrix {{ p.name }};
    long    {{ p.name }}_rowptr[{{ p.size[0]+1 }}];
    long    {{ p.name }}_colidx[{{ p.sparsity.nnz }}];
    double *{{ p.name }}_nzval;

    {% endfor %}
    {% if expressions %}
    /* Storage for intermediate results from expression evaluation. */
    {% for expr in expressions %}
    {% if not expr.inplace or expr.make_copy %}
    CsrMatrix {{ expr.name }};
    long   {{ expr.name }}_rowptr[{{ expr.size[0]+1 }}];
    long   {{ expr.name }}_colidx[{{ expr.sparsity.nnz }}];
    double {{ expr.name }}_nzval[{{ expr.sparsity.nnz }}];

    {% endif %}
    {% endfor %}

    /* Storage for the callback parameters. */
    {% for cbp in callback_params %}
    CscMatrix {{ cbp.cbp_name }};
    long   {{cbp.cbp_name}}_colptr[{{ cbp.size[1]+1 }}];
    long   {{cbp.cbp_name}}_rowidx[{{ cbp.sparsity.nnz }}];
    double {{cbp.cbp_name}}_nzval[{{ cbp.sparsity.nnz }}];
    {% endfor %}
    {% endif %}

    /* Matrices for referencing constants. (Data stored elsewhere.) */
    {% for c in constants %}
    CsrMatrix {{ c.name }};
    {% endfor %}
{% endmacro %}


{% if constants %}
/* Stored constant values used to evaluate expressions of parameters */
{% for c in constants %}
long   {{ c.name }}_rowptr{{ u.print_vec(c.rowptr) }};
long   {{ c.name }}_colidx{{ u.print_vec(c.colidx) }};
double {{ c.name }}_nzval{{ u.print_vec(c.nzval) }};

{% endfor %}
{% endif %}



{{ u.copy_declare() }} {# TODO add logic to python for including this or not #}
void init_dense_sparsity(CsrMatrix A);
{% for expr_name in unique_exprs %}
  {{- atoms.declare(expr_name) }}
{% endfor %}

void transpose(CsrMatrix A, CsrMatrix At);
void csr2csc(CsrMatrix A, CscMatrix B);



void param_init(Work *work){
    {% for e in expressions %}
    {% if not e.inplace or e.make_copy %}
    work->{{ e.name }}.p = work->{{ e.name }}_rowptr;
    work->{{ e.name }}.j = work->{{ e.name }}_colidx;
    work->{{ e.name }}.x = work->{{ e.name }}_nzval;
    work->{{ e.name }}.m = {{ e.size[0] }};
    work->{{ e.name }}.n = {{ e.size[1] }};
    work->{{ e.name }}.nnz = {{ e.sparsity.nnz }};
    {% endif %}

    {% endfor %}
    {% for p in named_params %}
    work->{{ p.name }}.p = work->{{ p.name }}_rowptr;
    work->{{ p.name }}.j = work->{{ p.name }}_colidx;
    work->{{ p.name }}.m = {{ p.size[0] }};
    work->{{ p.name }}.n = {{ p.size[1] }};
    work->{{ p.name }}.nnz = {{ p.sparsity.nnz }};

    init_dense_sparsity(work->{{ p.name }});
    {% endfor %}

    {% for cbp in callback_params %}
    work->{{ cbp.cbp_name }}.p = work->{{ cbp.cbp_name }}_colptr;
    work->{{ cbp.cbp_name }}.i = work->{{ cbp.cbp_name }}_rowidx;
    work->{{ cbp.cbp_name }}.x = work->{{ cbp.cbp_name }}_nzval;
    work->{{ cbp.cbp_name }}.m = {{ cbp.size[0] }};
    work->{{ cbp.cbp_name }}.n = {{ cbp.size[1] }};
    work->{{ cbp.cbp_name }}.nnz = {{ cbp.sparsity.nnz }};

    {% endfor %}

    {% for c in constants %}
    work->{{ c.name }}.p = {{ c.name }}_rowptr;
    work->{{ c.name }}.j = {{ c.name }}_colidx;
    work->{{ c.name }}.x = {{ c.name }}_nzval;
    work->{{ c.name }}.m = {{ c.size[0] }};
    work->{{ c.name }}.n = {{ c.size[1] }};
    work->{{ c.name }}.nnz = {{ c.sparsity.nnz }};

    {% endfor %}
}

void fill_param_tree(Params *params, Work *work){
    {# TODO Cut out the nzval pointer work struct, reduce this part: #}
    {% for p in named_params %}
    {{u.nzval(p)}} = &(params->{{ p.name -}}
        {%- if p.is_scalar -%}
        {%- elif p.is_column or p.is_row -%}
            [0]
        {%- else -%}
            [0][0]
        {%- endif -%});
    work->{{ p.name }}.x = work->{{ p.name }}_nzval;

    {% endfor %}
    {% for expr in expressions %}
    {{ atoms.eval(expr) -}}
    {% endfor %}

    {% for cbp in callback_params %}
    csr2csc(work->{{ cbp.storage.name }}, work->{{ cbp.cbp_name }});
    {% endfor %}
}


/* These are all functions of the parameters */
{% for expr_name in unique_exprs %}
  {{- atoms.define(expr_name) }}
{% endfor %}


{{ u.copy_define() }} // TODO add logic to python for this


void init_dense_sparsity(CsrMatrix A){
    long i, j, m=A.m, n=A.n;
    for(i=0; i<m; i++){
        A.p[i] = i*n;
        for(j=0; j<n; j++){
            A.j[i * n + j] = j;
        }
        A.p[m] = m*n;
    }
}


void transpose(CsrMatrix A, CsrMatrix At){
    long i, j, k, p2, ind, n=A.n, m=A.m, nnz=A.p[A.m];
    At.m = n;
    At.n = m;

    for (k=0; k<=n; k++)  At.p[k] = 0;
    for (k=0; k<nnz; k++) At.p[A.j[k]+1]++;
    for (i=0; i<n; i++) At.p[i+1] += At.p[i];

    for (i=0; i<m; i++){
        p2 = A.p[i+1];
        for (k=A.p[i]; k<p2; k++){
            j = A.j[k];
            ind = At.p[j];
            At.j[ind] = i;
            At.x[ind] = A.x[k];
            At.p[j]++;
        }
    }
    for (i=n; i>0; i--){
        At.p[i] = At.p[i-1];
    }
    At.p[0] = 0;
}

void csr2csc(CsrMatrix A, CscMatrix B){
    CsrMatrix At;
    At.p = B.p;
    At.j = B.i;
    At.x = B.x;
    transpose(A, At);
    B.m = A.n;
    B.n = A.m;
}
