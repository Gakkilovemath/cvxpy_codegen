{% import "utils/utils.c.jinja" as u with context %}
{% import "linop/linops/linops.c.jinja" as lo with context %}
#include "codegen.h"
#include <stdio.h> // TODO rm


{% macro linop_handler_workspace() %}
    /* Problem coefficients. */
    double obj_coeff[{{ x_length }}];
    double obj_offset;
    double eq_nzval[{{ eq_coeff.nnz }}];
    double eq_offset[{{ eq_dim }}];
    double leq_nzval[{{ leq_coeff.nnz }}];
    double leq_offset[{{ cone_dim }}];
    double obj_nzval[{{ obj_coeff.nnz }}];

    /* Storage for building matrices. */


    /* Matrix sparsity patterns. */
    long *leq_colptr;
    long *leq_rowidx;
    long *eq_colptr;
    long *eq_rowidx;


    /* Storage for the linear operator coefficients. */
    {% for c in linop_coeffs %}
    {% if not c.inplace or c.make_copy %}
    LinopCoeff {{ c.name }};
    long {{ c.name }}_rowptr[{{ c.size[0]+1 }}];
    long {{ c.name }}_colidx[{{ c.sparsity.nnz }}];
    double {{ c.name }}_nzval[{{ c.sparsity.nnz }}];
    {% endif %}

    {% endfor %}
    /* Storage for coefficients corresponding to variables. */
    {% for v in vars %}
    LinopCoeff {{ v.name }};
    long   {{ v.name }}_rowptr[{{ v.size[0]+1 }}];
    long   {{ v.name }}_colidx[{{ v.sparsity.nnz }}];
    double {{ v.name }}_nzval[{{ v.sparsity.nnz }}];

    {% endfor %}
    /* Storage for constants needed for linop evaluation. */
    {% for c in linop_constants %}
    CsrMatrix {{ c.name }}_mat;
    LinopCoeff {{ c.name}}; /* This is for the vectorized version. */
    long   {{ c.name }}_rowptr[{{ c.size[0]*c.size[1]+1 }}];
    long   {{ c.name }}_colidx[{{ c.sparsity.nnz }}];
    double {{ c.name }}_nzval[{{ c.sparsity.nnz }}];

    {% endfor %}

    // TODO more storage, for parameters
    // TODO more storage, for linop data
{% endmacro %}



{% if linop_constants %}
/* Stored constant values. */
{% for c in linop_constants %}
long   {{ c.name }}_rowptr{{ u.print_vec(c.rowptr) }};
long   {{ c.name }}_colidx{{ u.print_vec(c.colidx) }};
double {{ c.name }}_nzval{{ u.print_vec(c.nzval) }};

{% endfor %}
{% endif %}




/* Sparsity pattern for the objective and constraint matrices. */
long obj_colptr{{ u.print_vec(obj_coeff.indptr) }};
long obj_rowidx{{ u.print_vec(obj_coeff.indices) }};
long eq_colptr{{ u.print_vec(eq_coeff.indptr) }};
long eq_rowidx{{ u.print_vec(eq_coeff.indices) }};
long leq_colptr{{ u.print_vec(leq_coeff.indptr) }};
long leq_rowidx{{ u.print_vec(leq_coeff.indices) }};


// TODO
// static long *obj_colptr;
// static long *obj_rowidx;
// static long *eq_colptr;
// static long *eq_rowidx;
// static long *leq_colptr;
// static long *leq_rowidx;


void add_matrix(long m, long hshift, long vshift,
                long *Ap, long *Ai, double *Ax,
                long *Bp, long *Bj, double *Bx);
void reset_colptr(long m, long *Ap);
void get_colvec(double *vec, long offset, long len, long *Ap, double *Ax);
void get_rowvec(double *vec, long len, long *Ap, long *Aj, double *Ax);
void init_var_coeff(long m_var, long n_var, LinopCoeff *A);
{% for linop_name in unique_linops %}
  {{- lo.declare(linop_name) }}
{% endfor %}
// TODO organize where to put this:
void reshape(long m, long m_new,
             long *Ap, long *Aj, double *Ax,
             long *Zp, long *Zj, double *Zx);
void mat2coeff(CsrMatrix *A, LinopCoeff *C);
{{ u.copy_linop_declare() }} {# TODO add logic to python for including this or not #}

void linop_init(Work *work){
 
    printf("TP10\n");
    work->eq_colptr = eq_colptr;
    work->eq_rowidx = eq_rowidx;
    work->leq_colptr = leq_colptr;
    work->leq_rowidx = leq_rowidx;

    {% for c in linop_coeffs  %}
    {% if not c.inplace or c.make_copy %}
    work->{{ c.name }}.p = work->{{ c.name }}_rowptr;
    work->{{ c.name }}.j = work->{{ c.name }}_colidx;
    work->{{ c.name }}.x = work->{{ c.name }}_nzval;
    work->{{ c.name }}.m = {{ c.sparsity.shape[0] }};
    work->{{ c.name }}.n = {{ c.sparsity.shape[1] }};
    work->{{ c.name }}.nnz = {{ c.sparsity.nnz }};
    work->{{ c.name }}.m_var = {{ c.size[0] }};
    work->{{ c.name }}.n_var = {{ c.size[1] }};
    {% endif %}

    {% endfor %}

    printf("TP11\n");

    /* Storage for coefficients corresponding to variables. */
    {% for v in vars %}
    work->{{ v.name }}.p = work->{{ v.name }}_rowptr;
    work->{{ v.name }}.j = work->{{ v.name }}_colidx;
    work->{{ v.name }}.x = work->{{ v.name }}_nzval;
    printf("TP12\n");
    init_var_coeff({{ v.size[0]}}, {{v.size[1]}}, &work->{{ v.name }});

    {% endfor %}

    printf("TP13\n");

    /* Storage for linop coefficients representing constants. */
    {% for c in linop_constants %}
    work->{{ c.name }}_mat.p = {{ c.name }}_rowptr;
    work->{{ c.name }}_mat.j = {{ c.name }}_colidx;
    work->{{ c.name }}_mat.x = {{ c.name }}_nzval;
    work->{{ c.name }}_mat.m = {{ c.size[0] }};
    work->{{ c.name }}_mat.n = {{ c.size[1] }};
    work->{{ c.name }}_mat.nnz = {{ c.sparsity.nnz }};
    printf("TP14\n");
    work->{{ c.name }}.p = work->{{ c.name }}_rowptr;
    work->{{ c.name }}.j = work->{{ c.name }}_colidx;
    work->{{ c.name }}.x = work->{{ c.name }}_nzval;
    mat2coeff(&work->{{ c.name }}_mat, &work->{{ c.name }});

    {% endfor %}

    printf("TP15\n");

}








void fill_matrices(Params *params, Work *work){

  printf("TP20\n");

  {% for coeff in linop_coeffs %}
  {{ lo.eval(coeff) -}}
  {% endfor %}

  printf("TP21\n");

  /* Equality Constraints. */
  {% for c in eq_constr %}
  {% for coeff in c.linop.coeffs.values() %}
  {% if coeff.vid == CONST_ID %}
  get_colvec(work->eq_offset, {{ c.vert_offset}}, {{coeff.size[0]*coeff.size[1]}}, {{ u.rowptr(coeff) }}, {{ u.nzval(coeff) }});
  {% else %}
  add_matrix({{ coeff.sparsity.shape[0] }}, {{ var_offsets[coeff.vid] }}, {{ c.vert_offset }},
             eq_colptr, eq_rowidx, work->eq_nzval,
             {{ u.rowptr(coeff) }},  {{ u.colidx(coeff) }},  {{ u.nzval(coeff) }});
  {% endif %}
  {% endfor %}
  {% endfor %}

  printf("TP22\n");
  
  /* Inequality constraints. */
  {% for c in leq_constr %}
  {% for coeff in c.linop.coeffs.values() %}
  {% if coeff.vid == CONST_ID %}
  get_colvec(work->leq_offset, {{ c.vert_offset}}, {{coeff.size[0]*coeff.size[1]}}, {{ u.rowptr(coeff) }}, {{ u.nzval(coeff) }});
  {% else %}
  add_matrix({{ coeff.sparsity.shape[0] }}, {{ var_offsets[coeff.vid] }}, {{ c.vert_offset }},
             leq_colptr, leq_rowidx, work->leq_nzval,
             {{ u.rowptr(coeff) }},  {{ u.colidx(coeff) }},  {{ u.nzval(coeff) }});
  {% endif %}
  {% endfor %}
  {% endfor %}

  printf("TP23\n");
  
  /* Objective. */
  {% for coeff in objective.coeffs.values() %}
  {% if coeff.vid == CONST_ID %}
  get_colvec(&work->obj_offset, 0, 1, {{ u.rowptr(coeff) }}, {{ u.nzval(coeff) }});
  {#get_colvec(work->leq_offset, 0, {{coeff.size[0]*coeff.size[1]}}, {{ u.rowptr(coeff) }}, {{ u.nzval(coeff) }}); #}
  {% else %}
  add_matrix({{ coeff.sparsity.shape[0] }}, {{ var_offsets[coeff.vid] }}, 0,
             obj_colptr, obj_rowidx, work->obj_nzval,
             {{ u.rowptr(coeff) }},  {{ u.colidx(coeff) }},  {{ u.nzval(coeff) }});
  {% endif %}
  {% endfor %}
  reset_colptr({{ obj_coeff.nnz }}, obj_colptr);
  get_colvec(work->obj_coeff, 0, {{ x_length }},  obj_colptr, work->obj_nzval);

  printf("TP24\n");


  // TODO move these earlier?
  reset_colptr({{  eq_coeff.nnz }},  eq_colptr);
  reset_colptr({{ leq_coeff.nnz }}, leq_colptr);

  printf("TP25\n");
}



void get_colvec(double *vec, long offset, long len, long *Ap, double *Ax){
  long i, count=0;
  for (i=0; i<len; i++){
    vec[offset+i] = Ap[i] < Ap[i+1] ? Ax[count++] : 0;
  }
}



// TODO delete?
void get_rowvec(double *vec, long len, long *Ap, long *Aj, double *Ax){
  int i, nnz = Ap[1];
  for (i=0; i<len; i++)  vec[i] = 0;
  for (i=0; i<nnz; i++)  vec[Aj[i]] = Ax[i];
}



void add_matrix(long m, long hshift, long vshift,
                long *Ap, long *Ai, double *Ax,
                long *Bp, long *Bj, double *Bx){
  long i, j, p, p2, pA;
  for (i=0; i<m; i++){
    p2 = Bp[i+1];
    for (p=Bp[i]; p<p2; p++){
      j = Bj[p];
      pA = Ap[j+hshift]++; // TODO clean up
      // Ai[pA] = i+vshift; // TODO remove?
      Ax[pA] = Bx[p];
    }
  }
}


void reset_colptr(long m, long *Ap){
  int i;
  for (i=m; i>0; i--){
    Ap[i] = Ap[i-1];
  }
  Ap[0] = 0; 
}



void init_var_coeff(long m_var, long n_var, LinopCoeff *A){
    long m = m_var*n_var;
    A->m_var = m_var;
    A->n_var = n_var;
    A->m = m;
    A->n = m;
    A->nnz = m;
    long i;
    A->p[0] = 0;
    for(i=0; i<m; i++){
        A->p[i+1] = A->p[i]+1;
        A->j[i] = i;
        A->x[i] = 1.0;
    }
}



/* These are the linop definitions. */
{% for linop_name in unique_linops %}
  {{- lo.define(linop_name) }}
{% endfor %}



/* Vectorize a constant to be in Linop Coefficient format. */
void mat2coeff(CsrMatrix *A, LinopCoeff *C){
    CsrMatrix B;
    B.p = C->p;
    B.j = C->j;
    B.x = C->x;
    long m_new = A->m * A->n;
    reshape(A->m, m_new, A->p, A->j, A->x, B.p, B.j, B.x);
    C->m = m_new;
    C->n = 1;
    C->m_var = A->m;
    C->n_var = A->n;
    C->nnz = A->nnz;
}




void reshape(long m, long m_new,
             long *Ap, long *Aj, double *Ax,
             long *Zp, long *Zj, double *Zx){
  long i, j, i_new, j_new, idx, p, p2;

  for (i=0; i<=m_new; i++)  Zp[i] = 0;

  for (i=0; i<m; i++){
    p2 = Ap[i+1];
    for (p=Ap[i]; p<p2; p++){
      j = Aj[p];
      idx = j*m + i;
      i_new = idx % m_new;
      Zp[i_new+1]++;
    }
  }

  for (i=0; i<m_new; i++)  Zp[i+1] += Zp[i];

  for (i=0; i<m; i++){
    p2 = Ap[i+1];
    for (p=Ap[i]; p<p2; p++){
      j = Aj[p];
      idx = j*m + i;
      i_new = idx % m_new;
      idx -= i_new;
      j_new = idx/m_new;
      Zj[Zp[i_new]] = j_new;
      Zx[Zp[i_new]] = Ax[p];
      Zp[i_new]++;
    }
  }

  for (i=m_new; i>0; i--)  Zp[i] = Zp[i-1];
  Zp[0] = 0l;
}




{{ u.copy_linop_define() }}
